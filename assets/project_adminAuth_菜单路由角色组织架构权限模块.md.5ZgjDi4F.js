import{_ as e,c as a,R as s,o as l}from"./chunks/framework.D03bak1J.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"project/adminAuth/菜单路由角色组织架构权限模块.md","filePath":"project/adminAuth/菜单路由角色组织架构权限模块.md"}'),t={name:"project/adminAuth/菜单路由角色组织架构权限模块.md"};function n(o,i,r,h,p,c){return l(),a("div",null,i[0]||(i[0]=[s(`<h2 id="菜单获取" tabindex="-1">菜单获取 <a class="header-anchor" href="#菜单获取" aria-label="Permalink to &quot;菜单获取&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  parentId,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routeName,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sort,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  redirect,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  component,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1菜单, 2权限</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="component的解析" tabindex="-1">component的解析 <a class="header-anchor" href="#component的解析" aria-label="Permalink to &quot;component的解析&quot;">​</a></h3><ol><li>0 默认,普通路由页面,如果是叶子节点,就会跳转</li><li>1 叶子节点菜单,他后面children里的不会在菜单里渲染,这个页面得用子路由router-view渲染</li><li>2 隐藏节点菜单,不会在菜单中展示,通常是某个页面里的操作,详情等页面</li></ol><h2 id="菜单获取后的解析" tabindex="-1">菜单获取后的解析 <a class="header-anchor" href="#菜单获取后的解析" aria-label="Permalink to &quot;菜单获取后的解析&quot;">​</a></h2><ol><li>item.isGhostMenu = isGhostMenu(item) 判断是不是component为2,需要隐藏的菜单</li><li>item.isForceLeaf = isForceLeafMenu(item) 判断是不是component为1,叶子节点的菜单</li><li>item.isLeafMenu = isLeafMenu(item) 判断当前菜单是不是叶子菜单(左侧菜单显示时没有子菜单了),例如上面的isForceLeaf,或者下面children为空,或者是children里全是权限</li><li>item.isMenu = isMenu(item) type为1 判断是不是菜单,不是权限</li><li>如果item为isLeafMenu叶子菜单,把他下面children循环,把菜单放进item.children,把按钮权限放进item.buttons</li><li>后面就是继续从children里去递归</li><li>最终我们可以得到一个菜单树,每个菜单里面都知道他是什么属性,是菜单,还是权限,是叶子节点,还是隐藏节点</li></ol><h2 id="动态设置路由" tabindex="-1">动态设置路由 <a class="header-anchor" href="#动态设置路由" aria-label="Permalink to &quot;动态设置路由&quot;">​</a></h2><ol><li>先根据上面获得的菜单树递归把所有routeName的菜单节点放进一个map缓存,Map({routeName, item})</li><li>执行getAuthorizedRoutes,本地路由name字段和菜单树里routeName字段一一对应,根据服务器返回的菜单树过滤出有权限的路由</li></ol><div class="info custom-block"><p class="custom-block-title">getAuthorizedRoutes过程</p><ol><li>使用filter遍历本地路由,如果能在map缓存中找到当前路由,证明有权限,返回true,否则返回false</li><li>对当前route的children递归操作,同样使用filter进行过滤,最后结果重新赋值children</li><li>设置当前route的重定向属性,如果本身就有重定向的就直接用,否则用children的第一个,都没有就undefined</li></ol></div><ol start="3"><li>找到当前权限菜单树里第一个叶子节点菜单firstRoute,设置{ path: &#39;/&#39;, redirect: firstRoute } 重定向到第一个叶子节点菜单</li></ol><h2 id="权限控制" tabindex="-1">权限控制 <a class="header-anchor" href="#权限控制" aria-label="Permalink to &quot;权限控制&quot;">​</a></h2><p>我们权限控制分了多个细粒度的操作</p><ol><li>页面级别: 通过返回的权限控制路由addRoute去添加</li><li>组件级别: 使用高阶组件,通过v-if控制slot插槽的显示;异步组件也可以</li><li>按钮级别: 通过自定义指令v-permission控制按钮的显示,适用于ui展示和按钮功能的隐藏控制</li><li>hasPermission方法: 传入指定的权限,判断当前用户是否拥有该权限,可以灵活在js和jsx中使用,做到非常细粒度和全面的控制</li></ol>`,13)]))}const m=e(t,[["render",n]]);export{u as __pageData,m as default};
