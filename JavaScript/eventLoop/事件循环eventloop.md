## 何为进程
程序运行需要自己专属的内存空间，可以把这块内存空间简单理解为进程。每个应用至少一个进程，进程之间互相独立，即使要通信，也需要双方同意。

## 何为线程
有了进程后就可以运行程序的代码，运行代码的称为显线程。一个进程至少有一个线程，所以进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。

## 浏览器有什么进程和线程
浏览器是一个多进程多线程
的应用程序，为了避免相互影响，减少连环崩溃的概率，当启动浏览器后，他会自动启动多个进程

其中最主要的进程有
1. 浏览器进程：负责界面显示，用户交互，子进程管理。浏览器进程内部会启动多个线程处理不同的任务
2. 网络进程：负责加载网络资源
3. 渲染进程：渲染进程启动后，会开启一个渲染主线程，主线程负责执行HTML，css，js代码。默认情况下浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响


## 渲染主线程如何工作
1. 解析html
2. 解析css
3. 计算样式
4. 布局
5. 处理图层
6. 渲染(每秒页面画60次)
7. 执行全局js代码
8. 执行交互事件处理函数
9. 执行IO事件回调函数
10. 执行计时器回调函数

## 如何理解异步
JS是一门单线程的语言,这是因为他运行在浏览器的渲染主线程中,而渲染主线程一个标签页里只有一个
而渲染主线程承担着许多的工作,渲染页面执行js等都在里面执行
如果使用同步的方式,就极有可能阻塞主线程,从而导致任务队列中其他任务无法得到执行
这样一来,就会导致繁忙的主线程白白消耗时间,另一方面导致页面无法及时更新,给用户造成卡顿现象
所以浏览器采用了异步的方式来避免上面问题.具体做法是当某些任务发生时,例如计时器,网络,事件监听,主线程将任务交给其他线程处理,自身立即结束任务的执行,转而执行后续代码.当其他线程完成时,将事先传递的回调函数包装成任务加入到任务队列的末尾,等待主线程的调度执行
在这种异步模式下,浏览器可以最大限度保证单线程的流畅运行

## 任务优先级
浏览器必须准备好一个微队列,微队列的任务优先所有其他任务执行
在目前谷歌浏览器中,至少包含下面的队列
1. 延时队列: 用于存放计时器到达后的回调任务(中优先级)
2. 交互队列: 用于存放用户操作后产生的事件处理任务(高优先级)
3. 微队列: 用户存放需要最快执行的任务(最高优先级)

## 事件循环
事件循环又叫消息循环,是浏览器渲染主线程主要的工作方式
在Chrome的源码中,它开启一个不会结束的for循环,每次循环都从消息队列中取出第一个任务执行,而其他线程只需在合适的时候将任务加入到队列末尾即可
根据w3c标准每个任务有不同的类型,同类型的任务必须在同一队列,不同的任务属于不同的队列,不同任务队列有不同优先级,在一次事件循环中,由浏览器自行决定取哪个任务的队列,但浏览器中必须要有一个微队列,他具有最高优先级,必须先调度执行

## 浏览器渲染
浏览器渲染过程分为多个阶段,分别是html解析,计算样式,布局,分层,绘制,分块,光栅化,画

### 解析HTML(parse)
解析过程中遇到css解析css,遇到js执行js,为了提高解析效率,浏览器在开始解析前,会启动一个预解析的线程,率先下载html中外部的css文件和js文件

如果主线程解析到link位置,此时外部的css文件还没有下载解析好,主线程不会等待,继续解析后续的html.这是因为下载和解析css的工作是在预解析线程中进行,这就是css不会阻塞html解析的根本原因

如果主线程解析到script的位置,会停止解析html,转而等待js文件下载好,并将全局代码解析执行完成后,才继续解析html,这是因为js代码的执行过程可能会修改当前的dom树,所以dom树生成必须暂停,这就是js会阻塞html解析的根本原因

上面完成后,会得到dom树和cssom树,浏览器默认样式,内部样式,外部样式,行内样式均会包含在cssom树中

### 样式计算(style)
主线程遍历得到的dom树,依次为树中的每个节点计算出他的最终样式,这一过程中预设值会变为绝对值,比如red会变成rgb,相对单位变成绝对单位,例如em变为px,这一步之后会得到一棵带样式的dom树

### 布局(layout)
布局阶段会依次遍历dom树的每一个节点,计算节点的几何信息,比如节点的宽高
大部分时候dom树和布局树并非一一对应,比如display:none的节点没有几何信息,不会生成到布局树;

### 分层(layer)
主线程会使用一套复杂的策略对整个布局树进行分层,分层的好处在于将来某一层改变后,仅会对该层进行后续处理,从而提升效率
比如z-index,transform属性会影响分层结果

### 绘制(paint)
主线程会为每层单独产生绘制指令集,用于描述这一层的内容如何画出来.
完成绘制后主线程将每个图层的绘制信息交给合成线程,剩余工作由合成线程来完成
合成线程首先对每个图层进行分块,将其划分更多的小区域

### 光栅化
合成线程将块信息交给gpu进程,以极高的速度完成光栅化
gpu进程会开启多个线程完成光栅化,并且优先处理靠近视口区域的块,光栅化的结果就是一块一块的位图

### 画
合成线程拿到每个层,每个块的位图后,生成一个个指引quad信息
指引会标识每个位图应该画在屏幕的哪个位置,以及会考虑到旋转缩放等变形
变形发生在合成线程,与渲染主线程无关,这就是transform效率高的本质原因
合成线程会把quad提交给gpu进程,由gpu进程产生系统调用,提交给gpu硬件,完成最终的屏幕成像

## 什么时候重排
重排的本质就是重新计算布局树
当进行了会影响布局树的操作后,需要重新计算布局树,会引发重排
为了避免连续多次操作导致布局树反复计算,浏览器会合并这些操作,当js代码全部完成后在进行统一计算,所以改动属性造成的重排是异步完成
也同样因为如此,当js获取布局属性时,就可能造成无法获取最新的布局信息,最终在权衡下决定获取属性时立即重排

## 什么是重绘
重绘的本质就是重新根据分层信息计算了绘制指令
当改动了可见样式后,就需要重新计算,会因为重绘
由于元素的布局信息也算可见样式,所以重排必定导致重绘